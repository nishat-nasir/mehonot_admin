import 'package:cloud_firestore/cloud_firestore.dart';import 'package:mehonot_admin/manager/models/resume/skill_md.dart';import '../../../presentation/template/template.dart';import '../../../presentation/utils/constants.dart';import '../../firebase/firebase_kit.dart';import '../../hive_client.dart';import '../../models/Address/address_md.dart';import '../../models/Job/job_md.dart';import '../../models/User/user_md.dart';import '../../models/User/user_profile_md.dart';import '../../models/resume/education_md.dart';import '../../models/resume/experience_md.dart';import '../states/jobs_state.dart';import '../states/user_state.dart';class UserMiddleware extends MiddlewareClass<AppState> {  @override  call(Store<AppState> store, action, next) {    switch (action.runtimeType) {      case GetUserProfileAction:        return _getUserProfileAction(store.state, action, next);      case GetUpdateAccountAction:        return _getUpdateAccountAction(store.state, action, next);      case GetUpdateProfileAction:        return _getUpdateProfileAction(store.state, action, next);      case GetUpdateSavedJobsAction:        return _getUpdateSavedJobsAction(store.state, action, next);      case GetAllMySavedJobsAction:        return _getAllMySavedJobsAction(store.state, action, next);      default:        return next(action);    }  }}Future<UserProfileModel?> _getUserProfileAction(    AppState state, GetUserProfileAction action, NextDispatcher next) async {  try {    logger("GetUserProfileAction -- Called");    showLoading();    UserProfileModel userProfileModel;    CollectionReference users = FirebaseKit().usersCollection;    userProfileModel = await users        .doc(action.userId)        .collection(userProfileFbDb)        .doc(action.userProfileId)        .get()        .then((value) {      logger(value.data(), hint: 'GetUserProfileAction_TEST');      return UserProfileModel(        userId: value['userId'],        userProfileId: value['userProfileId'],        firstName: value['firstName'],        lastName: value['lastName'],        createdDate: value['createdDate'],        email: value['email'],        contactNumber: value['contactNumber'],        address: AddressModel(          division: value['address']['division'],          district: value['address']['district'],          city: value['address']['city'],          area: value['address']['area'],        ),        profileImage: value['profileImage'],        skill:            List.from(value['skill']?.map((e) => SkillModel.fromJson(e)) ?? []),        education: List.from(            value['education']?.map((e) => EducationModel.fromJson(e)) ?? []),        experience: List.from(            value['experience']?.map((e) => ExperienceModel.fromJson(e)) ?? []),        myJobsIds: (value['myJobsIds'] is List)            ? List<String>.from(                value['myJobsIds']?.map((e) => e.toString()) ?? [])            : null,        birthday: value['birthday'],        bio: value['bio'],        positionTitle: value['positionTitle'],        savedJobsIds: value['savedJobsIds'] != null            ? List<String>.from(                value['savedJobsIds'].map((element) => element.toString()))            : null,        isVerifiedExplorer: value['isVerifiedExplorer'],        isVerifiedOwner: value['isVerifiedOwner'],      );    });    closeLoading();    next(UpdateUserStateAction(      userProfileData: userProfileModel,    ));    HiveClient.setDivision(userProfileModel.address.division);    await appStore.dispatch(GetJobsAction(      division: convertStringToDivision(          HiveClient.getDivision() ?? userProfileModel.address.division),    ));    return userProfileModel;  } catch (e) {    closeLoading();    logger(e.toString(), hint: 'Get User By Id CATCH ERROR');    return null;  }}Future<bool> _getUpdateAccountAction(    AppState state, GetUpdateAccountAction action, NextDispatcher next) async {  try {    logger("GetUpdateAccountAction -- Called"); // //Saving old user info    UserModel oldUserData = UserModel(      userId: state.userState.userData.userId,      userProfileId: state.userState.userData.userProfileId,      password: state.userState.userData.password,      phoneNumber: state.userState.userData.phoneNumber,      isAdmin: state.userState.userData.isAdmin,    );    await FirebaseKit()        .usersCollection        .doc(state.userState.userData.userId)        .update({      "userId": action.userData.userId,      "password": action.userData.password,      "phoneNumber": action.userData.phoneNumber,      "isAdmin": action.userData.isAdmin,    });    UserModel? updatedUser = await appStore.dispatch(GetUserProfileAction(        userId: state.userState.userData.userId,        userProfileId: state.userState.userData.userProfileId));    if (updatedUser != null) {      next(UpdateUserStateAction(userData: updatedUser));    } else {      await FirebaseKit()          .usersCollection          .doc(state.userState.userData.userId)          .update({        "userId": oldUserData.userId,        "password": oldUserData.password,        "phoneNumber": oldUserData.phoneNumber,        "isAdmin": oldUserData.isAdmin,      });    }    closeLoading();    return true;  } catch (e) {    closeLoading();    logger(e.toString(), hint: 'GET UPDATE POST CATCH ERROR');    return false;  }}Future<bool> _getUpdateProfileAction(    AppState state, GetUpdateProfileAction action, NextDispatcher next) async {  try {    logger("GetUpdateProfileAction -- Called");    CollectionReference usersCollection = FirebaseKit().usersCollection;    await usersCollection        .doc(action.userProfileData.userId)        .collection(userProfileFbDb)        .doc(action.userProfileData.userProfileId)        .update({      "firstName": action.userProfileData.firstName,      "lastName": action.userProfileData.lastName,      "email": action.userProfileData.email,      "contactNumber": action.userProfileData.contactNumber,      "address": {        "division": action.userProfileData.address.division,        "district": action.userProfileData.address.district,        "city": action.userProfileData.address.city,        "area": action.userProfileData.address.area,      },      "profileImage": action.userProfileData.profileImage,      "myJobsIds": action.userProfileData.myJobsIds,      "education":          action.userProfileData.education?.map((e) => e.toJson()).toList(),      "experience":          action.userProfileData.experience?.map((e) => e.toJson()).toList(),      "skill": action.userProfileData.skill?.map((e) => e.toJson()).toList(),      "birthday": action.userProfileData.birthday,      "bio": action.userProfileData.bio,      "positionTitle": action.userProfileData.positionTitle,    });    return true;  } catch (e) {    logger(e.toString(), hint: 'GetUpdateJobAction CATCH ERROR');    return false;  }}Future<bool> _getUpdateSavedJobsAction(AppState state,    GetUpdateSavedJobsAction action, NextDispatcher next) async {  try {    logger("GetUpdateSavedJobsAction -- Called");    String jobId = action.jobData.jobId;    if (state.userState.userProfileData.savedJobsIds != null &&        state.userState.userProfileData.savedJobsIds!.contains(jobId)) {      await FirebaseKit()          .usersCollection          .doc(state.userState.userData.userId)          .collection(userProfileFbDb)          .doc(state.userState.userData.userProfileId)          .update({        "savedJobsIds": FieldValue.arrayRemove([jobId]),      }).then((value) {        appStore.dispatch(UpdateUserStateAction(            userProfileData: UserProfileModel(              userId: state.userState.userProfileData.userId,              userProfileId: state.userState.userProfileData.userProfileId,              firstName: state.userState.userProfileData.firstName,              lastName: state.userState.userProfileData.lastName,              email: state.userState.userProfileData.email,              contactNumber: state.userState.userProfileData.contactNumber,              address: state.userState.userProfileData.address,              profileImage: state.userState.userProfileData.profileImage,              myJobsIds: state.userState.userProfileData.myJobsIds,              education: state.userState.userProfileData.education,              experience: state.userState.userProfileData.experience,              skill: state.userState.userProfileData.skill,              birthday: state.userState.userProfileData.birthday,              bio: state.userState.userProfileData.bio,              positionTitle: state.userState.userProfileData.positionTitle,              savedJobsIds: state.userState.userProfileData.savedJobsIds!                ..remove(jobId),              createdDate: state.userState.userProfileData.createdDate,            ),            mySavedJobsJobData: state.userState.mySavedJobsJobData              ..removeWhere((element) => element.jobId == jobId)));      });      return true;    } else {      await FirebaseKit()          .usersCollection          .doc(state.userState.userData.userId)          .collection(userProfileFbDb)          .doc(state.userState.userData.userProfileId)          .update({        "savedJobsIds": FieldValue.arrayUnion([jobId]),      }).then((value) {        appStore.dispatch(UpdateUserStateAction(            userProfileData: UserProfileModel(              userId: state.userState.userProfileData.userId,              userProfileId: state.userState.userProfileData.userProfileId,              firstName: state.userState.userProfileData.firstName,              lastName: state.userState.userProfileData.lastName,              email: state.userState.userProfileData.email,              contactNumber: state.userState.userProfileData.contactNumber,              address: state.userState.userProfileData.address,              profileImage: state.userState.userProfileData.profileImage,              myJobsIds: state.userState.userProfileData.myJobsIds,              education: state.userState.userProfileData.education,              experience: state.userState.userProfileData.experience,              skill: state.userState.userProfileData.skill,              birthday: state.userState.userProfileData.birthday,              bio: state.userState.userProfileData.bio,              positionTitle: state.userState.userProfileData.positionTitle,              createdDate: state.userState.userProfileData.createdDate,              savedJobsIds: state.userState.userProfileData.savedJobsIds == null                  ? [jobId]                  : state.userState.userProfileData.savedJobsIds!                ..add(jobId),            ),            mySavedJobsJobData: state.userState.mySavedJobsJobData              ..add(action.jobData)));      });      return true;    }  } catch (e) {    logger(e.toString(), hint: 'GetUpdateSavedJobsAction CATCH ERROR');    return false;  }}Future<bool> _getAllMySavedJobsAction(    AppState state, GetAllMySavedJobsAction action, NextDispatcher next) async {  try {    logger("GetAllMySavedJobsAction -- Called");    List<String> jobsList = [];    List<JobModel> mySavedJobs = [];    if (state.userState.userProfileData.savedJobsIds != null &&        state.userState.userProfileData.savedJobsIds!.isNotEmpty) {      jobsList = state.userState.userProfileData.savedJobsIds!;    }    for (int i = 0; i < jobsList.length; i++) {      Division division =          convertStringToDivision(jobsList[i].split('_')[0].capitalize());      JobModel job = await appStore.dispatch(          GetJobDataByIdAction(jobId: jobsList[i], jobDivision: division));      mySavedJobs.add(job);    }    next(UpdateUserStateAction(mySavedJobsJobData: mySavedJobs));    return true;  } catch (e) {    logger(e.toString(), hint: 'GetAllMySavedJobsAction CATCH ERROR');    return false;  }}
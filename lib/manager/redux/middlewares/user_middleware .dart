import 'package:cloud_firestore/cloud_firestore.dart';import 'package:mehonot_admin/manager/models/resume/skill_md.dart';import '../../../presentation/template/template.dart';import '../../../presentation/utils/constants.dart';import '../../firebase/firebase_kit.dart';import '../../hive_client.dart';import '../../models/Address/address_md.dart';import '../../models/Job/job_md.dart';import '../../models/User/user_job_relation_md.dart';import '../../models/User/user_md.dart';import '../../models/User/user_profile_md.dart';import '../../models/resume/education_md.dart';import '../../models/resume/experience_md.dart';import '../states/jobs_state.dart';import '../states/user_state.dart';class UserMiddleware extends MiddlewareClass<AppState> {  @override  call(Store<AppState> store, action, next) {    switch (action.runtimeType) {      case GetUserProfileAction:        return _getUserProfileAction(store.state, action, next);      case GetUserJobRelationAction:        return _getUserJobRelationAction(store.state, action, next);      case GetUpdateAccountAction:        return _getUpdateAccountAction(store.state, action, next);      case GetUpdateProfileAction:        return _getUpdateProfileAction(store.state, action, next);      case GetUpdateSavedJobsAction:        return _getUpdateSavedJobsAction(store.state, action, next);      case GetUpdateSavedJobsRemoveReqAction:        return _getUpdateSavedJobsRemoveReqAction(store.state, action, next);      case GetAllMySavedJobsAction:        return _getAllMySavedJobsAction(store.state, action, next);      case GetPostFeedbackAction:        return _getPostFeedbackAction(store.state, action, next);      default:        return next(action);    }  }}Future<UserProfileModel?> _getUserProfileAction(    AppState state, GetUserProfileAction action, NextDispatcher next) async {  try {    logger("GetUserProfileAction -- Called");    showLoading();    UserProfileModel userProfileModel;    CollectionReference usersProfile = FirebaseKit().usersProfilesCollection;    userProfileModel =        await usersProfile.doc(action.userProfileId).get().then((value) {      logger(value.data(), hint: 'GetUserProfileAction_TEST');      return UserProfileModel(        userId: value['userId'],        userProfileId: value['userProfileId'],        userJobRelationId: value['userJobRelationId'],        firstName: value['firstName'],        lastName: value['lastName'],        createdDate: value['createdDate'],        email: value['email'],        contactNumber: value['contactNumber'],        address: AddressModel(          division: value['address']['division'],          district: value['address']['district'],          city: value['address']['city'],          area: value['address']['area'],        ),        profileImage: value['profileImage'],        skill:            List.from(value['skill']?.map((e) => SkillModel.fromJson(e)) ?? []),        education: List.from(            value['education']?.map((e) => EducationModel.fromJson(e)) ?? []),        experience: List.from(            value['experience']?.map((e) => ExperienceModel.fromJson(e)) ?? []),        birthday: value['birthday'],        bio: value['bio'],        positionTitle: value['positionTitle'],        isVerifiedExplorer: value['isVerifiedExplorer'],        isVerifiedOwner: value['isVerifiedOwner'],      );    });    await appStore.dispatch(GetUserJobRelationAction(      userProfileId: userProfileModel.userProfileId,      userJobRelationId: userProfileModel.userJobRelationId,    ));    closeLoading();    next(UpdateUserStateAction(userProfileData: userProfileModel));    HiveClient.setDivision(userProfileModel.address.division);    await appStore.dispatch(GetJobsAction(      division: convertStringToDivision(          HiveClient.getDivision() ?? userProfileModel.address.division),    ));    return userProfileModel;  } catch (e) {    closeLoading();    logger(e.toString(), hint: 'Get User By Id CATCH ERROR');    return null;  }}Future<bool> _getUserJobRelationAction(AppState state,    GetUserJobRelationAction action, NextDispatcher next) async {  try {    logger("GetUserJobRelationAction -- Called");    showLoading();    UserJobRelationMd userJobRelationData;    CollectionReference usersProfilesCol =        FirebaseKit().usersProfilesCollection;    userJobRelationData = await usersProfilesCol        .doc(action.userProfileId)        .collection(userProfileJobRelationsFbDb)        .doc(action.userJobRelationId)        .get()        .then((value) {      logger(value.data(), hint: 'GetUserJobRelationAction_TEST');      return UserJobRelationMd(        myJobsIds: List.from(value['myJobsIds'] ?? []),        savedJobsIds: List.from(value['savedJobsIds'] ?? []),        userProfileId: value['userProfileId'],        appliedJobsIds: List.from(value['appliedJobsIds'] ?? []),      );    });    closeLoading();    next(UpdateUserStateAction(      userJobRelationData: userJobRelationData,    ));    return true;  } catch (e) {    closeLoading();    logger(e.toString(), hint: 'GetUserJobRelation CATCH ERROR');    return false;  }}Future<bool> _getUpdateAccountAction(    AppState state, GetUpdateAccountAction action, NextDispatcher next) async {  try {    logger("GetUpdateAccountAction -- Called"); // //Saving old user info    UserModel oldUserData = UserModel(      userId: state.userState.userData.userId,      userProfileId: state.userState.userData.userProfileId,      password: state.userState.userData.password,      phoneNumber: state.userState.userData.phoneNumber,      isAdmin: state.userState.userData.isAdmin,    );    await FirebaseKit()        .usersCollection        .doc(state.userState.userData.userId)        .update({      "userId": action.userData.userId,      "password": action.userData.password,      "phoneNumber": action.userData.phoneNumber,      "isAdmin": action.userData.isAdmin,    });    UserModel? updatedUser = await appStore.dispatch(GetUserProfileAction(        userProfileId: state.userState.userData.userProfileId));    if (updatedUser != null) {      next(UpdateUserStateAction(userData: updatedUser));    } else {      await FirebaseKit()          .usersCollection          .doc(state.userState.userData.userId)          .update({        "userId": oldUserData.userId,        "password": oldUserData.password,        "phoneNumber": oldUserData.phoneNumber,        "isAdmin": oldUserData.isAdmin,      });    }    closeLoading();    return true;  } catch (e) {    closeLoading();    logger(e.toString(), hint: 'GET UPDATE POST CATCH ERROR');    return false;  }}Future<bool> _getUpdateProfileAction(    AppState state, GetUpdateProfileAction action, NextDispatcher next) async {  try {    logger("GetUpdateProfileAction -- Called");    CollectionReference usersProfileCollection =        FirebaseKit().usersProfilesCollection;    await usersProfileCollection        .doc(action.userProfileData.userProfileId)        .update({      "firstName": action.userProfileData.firstName,      "lastName": action.userProfileData.lastName,      "email": action.userProfileData.email,      "contactNumber": action.userProfileData.contactNumber,      "address": {        "division": action.userProfileData.address.division,        "district": action.userProfileData.address.district,        "city": action.userProfileData.address.city,        "area": action.userProfileData.address.area,      },      "profileImage": action.userProfileData.profileImage,      "education":          action.userProfileData.education?.map((e) => e.toJson()).toList(),      "experience":          action.userProfileData.experience?.map((e) => e.toJson()).toList(),      "skill": action.userProfileData.skill?.map((e) => e.toJson()).toList(),      "birthday": action.userProfileData.birthday,      "bio": action.userProfileData.bio,      "positionTitle": action.userProfileData.positionTitle,    });    return true;  } catch (e) {    logger(e.toString(), hint: 'GetUpdateJobAction CATCH ERROR');    return false;  }}Future<bool> _getUpdateSavedJobsAction(AppState state,    GetUpdateSavedJobsAction action, NextDispatcher next) async {  try {    logger("GetUpdateSavedJobsAction -- Called");    String jobId = action.jobData.jobId;    CollectionReference usersProfileCollection =        FirebaseKit().usersProfilesCollection;    if (state.userState.userJobRelationData.savedJobsIds.contains(jobId)) {      await usersProfileCollection          .doc(state.userState.userData.userProfileId)          .collection(userProfileJobRelationsFbDb)          .doc(state.userState.userProfileData.userJobRelationId)          .update({        "savedJobsIds": FieldValue.arrayRemove([jobId]),      }).then((value) {        appStore.dispatch(UpdateUserStateAction(          userJobRelationData: UserJobRelationMd(            userProfileId: state.userState.userJobRelationData.userProfileId,            myJobsIds: state.userState.userJobRelationData.myJobsIds,            appliedJobsIds: state.userState.userJobRelationData.appliedJobsIds,            savedJobsIds: state.userState.userJobRelationData.savedJobsIds              ..remove(jobId),          ),        ));      });      return true;    } else {      await usersProfileCollection          .doc(state.userState.userData.userProfileId)          .collection(userProfileJobRelationsFbDb)          .doc(state.userState.userProfileData.userJobRelationId)          .update({        "savedJobsIds": FieldValue.arrayUnion([jobId]),      }).then((value) {        appStore.dispatch(UpdateUserStateAction(          userJobRelationData: UserJobRelationMd(            userProfileId: state.userState.userJobRelationData.userProfileId,            myJobsIds: state.userState.userJobRelationData.myJobsIds,            appliedJobsIds: state.userState.userJobRelationData.appliedJobsIds,            savedJobsIds: state.userState.userJobRelationData.savedJobsIds              ..add(jobId),          ),        ));      });      return true;    }  } catch (e) {    logger(e.toString(), hint: 'GetUpdateSavedJobsAction CATCH ERROR');    return false;  }}Future<bool> _getAllMySavedJobsAction(    AppState state, GetAllMySavedJobsAction action, NextDispatcher next) async {  try {    logger("GetAllMySavedJobsAction -- Called");    List<String> jobsList = [];    List<JobModel> mySavedJobs = [];    if (state.userState.userJobRelationData.savedJobsIds.isNotEmpty) {      jobsList = state.userState.userJobRelationData.savedJobsIds;    }    for (int i = 0; i < jobsList.length; i++) {      Division division =          convertStringToDivision(jobsList[i].split('_')[0].capitalize());      JobModel job = await appStore.dispatch(          GetJobDataByIdAction(jobId: jobsList[i], jobDivision: division));      mySavedJobs.add(job);    }    next(UpdateUserStateAction(        userJobRelationData: UserJobRelationMd(          userProfileId: state.userState.userJobRelationData.userProfileId,          myJobsIds: state.userState.userJobRelationData.myJobsIds,          appliedJobsIds: state.userState.userJobRelationData.appliedJobsIds,          savedJobsIds: state.userState.userJobRelationData.savedJobsIds,        ),        mySavedJobsJobData: mySavedJobs));    return true;  } catch (e) {    logger(e.toString(), hint: 'GetAllMySavedJobsAction CATCH ERROR');    return false;  }}Future<bool> _getUpdateSavedJobsRemoveReqAction(AppState state,    GetUpdateSavedJobsRemoveReqAction action, NextDispatcher next) async {  try {    logger("GetUpdateSavedJobsAction -- Called");    String jobId = "action";    CollectionReference usersProfileCollection =        FirebaseKit().usersProfilesCollection;    if (state.userState.userJobRelationData.savedJobsIds.contains(jobId)) {      await usersProfileCollection          .doc(state.userState.userData.userProfileId)          .collection(userProfileJobRelationsFbDb)          .doc(state.userState.userProfileData.userJobRelationId)          .update({        "savedJobsIds": FieldValue.arrayRemove([jobId]),      }).then((value) {        appStore.dispatch(UpdateUserStateAction(            userJobRelationData: UserJobRelationMd(          userProfileId: state.userState.userJobRelationData.userProfileId,          myJobsIds: state.userState.userJobRelationData.myJobsIds,          appliedJobsIds: state.userState.userJobRelationData.appliedJobsIds,          savedJobsIds: state.userState.userJobRelationData.savedJobsIds            ..remove(jobId),        )));      });    }    return true;  } catch (e) {    return false;  }}Future<bool> _getPostFeedbackAction(    AppState state, GetPostFeedbackAction action, NextDispatcher next) async {  try {    logger("GetPostFeedbackAction -- Called");    await FirebaseKit().feedbackCollection.doc().set({      "userId": action.userData.userId,      "userProfileId": action.userData.userProfileId,      "feedback": action.feedback,      "rating": action.rating,      "createdAt": DateTime.now(),    });    return true;  } catch (e) {    logger(e.toString(), hint: 'GetPostFeedbackAction CATCH ERROR');    return false;  }}